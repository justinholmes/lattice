// This file was generated by counterfeiter
package fake_blob_store

import (
	"io"
	"sync"

	"github.com/cloudfoundry-incubator/lattice/ltc/config/dav_blob_store"
	"github.com/cloudfoundry-incubator/lattice/ltc/droplet_runner"
)

type FakeBlobStore struct {
	ListStub        func() ([]dav_blob_store.Blob, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct{}
	listReturns     struct {
		result1 []dav_blob_store.Blob
		result2 error
	}
	DeleteStub        func(path string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		path string
	}
	deleteReturns struct {
		result1 error
	}
	UploadStub        func(path string, contents io.ReadSeeker) error
	uploadMutex       sync.RWMutex
	uploadArgsForCall []struct {
		path     string
		contents io.ReadSeeker
	}
	uploadReturns struct {
		result1 error
	}
	DownloadStub        func(path string) (io.ReadCloser, error)
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		path string
	}
	downloadReturns struct {
		result1 io.ReadCloser
		result2 error
	}
}

func (fake *FakeBlobStore) List() ([]dav_blob_store.Blob, error) {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct{}{})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub()
	} else {
		return fake.listReturns.result1, fake.listReturns.result2
	}
}

func (fake *FakeBlobStore) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeBlobStore) ListReturns(result1 []dav_blob_store.Blob, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []dav_blob_store.Blob
		result2 error
	}{result1, result2}
}

func (fake *FakeBlobStore) Delete(path string) error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		path string
	}{path})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(path)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeBlobStore) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBlobStore) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].path
}

func (fake *FakeBlobStore) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlobStore) Upload(path string, contents io.ReadSeeker) error {
	fake.uploadMutex.Lock()
	fake.uploadArgsForCall = append(fake.uploadArgsForCall, struct {
		path     string
		contents io.ReadSeeker
	}{path, contents})
	fake.uploadMutex.Unlock()
	if fake.UploadStub != nil {
		return fake.UploadStub(path, contents)
	} else {
		return fake.uploadReturns.result1
	}
}

func (fake *FakeBlobStore) UploadCallCount() int {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	return len(fake.uploadArgsForCall)
}

func (fake *FakeBlobStore) UploadArgsForCall(i int) (string, io.ReadSeeker) {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	return fake.uploadArgsForCall[i].path, fake.uploadArgsForCall[i].contents
}

func (fake *FakeBlobStore) UploadReturns(result1 error) {
	fake.UploadStub = nil
	fake.uploadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlobStore) Download(path string) (io.ReadCloser, error) {
	fake.downloadMutex.Lock()
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		path string
	}{path})
	fake.downloadMutex.Unlock()
	if fake.DownloadStub != nil {
		return fake.DownloadStub(path)
	} else {
		return fake.downloadReturns.result1, fake.downloadReturns.result2
	}
}

func (fake *FakeBlobStore) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeBlobStore) DownloadArgsForCall(i int) string {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return fake.downloadArgsForCall[i].path
}

func (fake *FakeBlobStore) DownloadReturns(result1 io.ReadCloser, result2 error) {
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

var _ droplet_runner.BlobStore = new(FakeBlobStore)
